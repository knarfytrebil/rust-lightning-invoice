var data = {lines:[
{"lineNum":"    1","line":"use core::marker::PhantomData;"},
{"lineNum":"    2","line":"use ffi;"},
{"lineNum":"    3","line":"use types::{c_uint, c_void};"},
{"lineNum":"    4","line":"use Error;"},
{"lineNum":"    5","line":"use Secp256k1;"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"#[cfg(feature = \"std\")]"},
{"lineNum":"    8","line":"pub use self::std_only::*;"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"/// A trait for all kinds of Context\'s that Lets you define the exact flags and a function to deallocate memory."},
{"lineNum":"   11","line":"/// * DO NOT * implement it for your own types."},
{"lineNum":"   12","line":"pub unsafe trait Context {"},
{"lineNum":"   13","line":"    /// Flags for the ffi."},
{"lineNum":"   14","line":"    const FLAGS: c_uint;"},
{"lineNum":"   15","line":"    /// A constant description of the context."},
{"lineNum":"   16","line":"    const DESCRIPTION: &\'static str;"},
{"lineNum":"   17","line":"    /// A function to deallocate the memory when the context is dropped."},
{"lineNum":"   18","line":"    fn deallocate(ptr: *mut [u8]);"},
{"lineNum":"   19","line":"}"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/// Marker trait for indicating that an instance of `Secp256k1` can be used for signing."},
{"lineNum":"   22","line":"pub trait Signing: Context {}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"/// Marker trait for indicating that an instance of `Secp256k1` can be used for verification."},
{"lineNum":"   25","line":"pub trait Verification: Context {}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"/// Represents the set of capabilities needed for signing with a user preallocated memory."},
{"lineNum":"   28","line":"pub struct SignOnlyPreallocated<\'buf> {"},
{"lineNum":"   29","line":"    phantom: PhantomData<&\'buf ()>,"},
{"lineNum":"   30","line":"}"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"/// Represents the set of capabilities needed for verification with a user preallocated memory."},
{"lineNum":"   33","line":"pub struct VerifyOnlyPreallocated<\'buf> {"},
{"lineNum":"   34","line":"    phantom: PhantomData<&\'buf ()>,"},
{"lineNum":"   35","line":"}"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"/// Represents the set of all capabilities with a user preallocated memory."},
{"lineNum":"   38","line":"pub struct AllPreallocated<\'buf> {"},
{"lineNum":"   39","line":"    phantom: PhantomData<&\'buf ()>,"},
{"lineNum":"   40","line":"}"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"#[cfg(feature = \"std\")]"},
{"lineNum":"   43","line":"mod std_only {"},
{"lineNum":"   44","line":"    use super::*;"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"    /// Represents the set of capabilities needed for signing."},
{"lineNum":"   47","line":"    pub enum SignOnly {}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    /// Represents the set of capabilities needed for verification."},
{"lineNum":"   50","line":"    pub enum VerifyOnly {}"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    /// Represents the set of all capabilities."},
{"lineNum":"   53","line":"    pub enum All {}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"    impl Signing for SignOnly {}"},
{"lineNum":"   56","line":"    impl Signing for All {}"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"    impl Verification for VerifyOnly {}"},
{"lineNum":"   59","line":"    impl Verification for All {}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    unsafe impl Context for SignOnly {"},
{"lineNum":"   62","line":"        const FLAGS: c_uint = ffi::SECP256K1_START_SIGN;"},
{"lineNum":"   63","line":"        const DESCRIPTION: &\'static str = \"signing only\";"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"        fn deallocate(ptr: *mut [u8]) {"},
{"lineNum":"   66","line":"            let _ = unsafe { Box::from_raw(ptr) };"},
{"lineNum":"   67","line":"        }"},
{"lineNum":"   68","line":"    }"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    unsafe impl Context for VerifyOnly {"},
{"lineNum":"   71","line":"        const FLAGS: c_uint = ffi::SECP256K1_START_VERIFY;"},
{"lineNum":"   72","line":"        const DESCRIPTION: &\'static str = \"verification only\";"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"        fn deallocate(ptr: *mut [u8]) {"},
{"lineNum":"   75","line":"            let _ = unsafe { Box::from_raw(ptr) };"},
{"lineNum":"   76","line":"        }"},
{"lineNum":"   77","line":"    }"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    unsafe impl Context for All {"},
{"lineNum":"   80","line":"        const FLAGS: c_uint = VerifyOnly::FLAGS | SignOnly::FLAGS;"},
{"lineNum":"   81","line":"        const DESCRIPTION: &\'static str = \"all capabilities\";"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"        fn deallocate(ptr: *mut [u8]) {","class":"lineCov","hits":"1","order":"5264","possible_hits":"1",},
{"lineNum":"   84","line":"            let _ = unsafe { Box::from_raw(ptr) };","class":"lineCov","hits":"1","order":"5265","possible_hits":"1",},
{"lineNum":"   85","line":"        }","class":"linePartCov","hits":"1","order":"5271","possible_hits":"2",},
{"lineNum":"   86","line":"    }"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"    impl<C: Context> Secp256k1<C> {"},
{"lineNum":"   89","line":"        /// Lets you create a context in a generic manner(sign/verify/all)"},
{"lineNum":"   90","line":"        pub fn gen_new() -> Secp256k1<C> {","class":"lineCov","hits":"1","order":"3804","possible_hits":"1",},
{"lineNum":"   91","line":"            let buf = vec![0u8; Self::preallocate_size_gen()].into_boxed_slice();","class":"lineCov","hits":"1","order":"3805","possible_hits":"1",},
{"lineNum":"   92","line":"            let ptr = Box::into_raw(buf);","class":"lineCov","hits":"1","order":"3851","possible_hits":"1",},
{"lineNum":"   93","line":"            Secp256k1 {","class":"lineCov","hits":"1","order":"4823","possible_hits":"1",},
{"lineNum":"   94","line":"                ctx: unsafe { ffi::secp256k1_context_preallocated_create(ptr as *mut c_void, C::FLAGS) },","class":"lineCov","hits":"1","order":"3866","possible_hits":"1",},
{"lineNum":"   95","line":"                phantom: PhantomData,"},
{"lineNum":"   96","line":"                buf: ptr,","class":"lineCov","hits":"1","order":"4822","possible_hits":"1",},
{"lineNum":"   97","line":"            }"},
{"lineNum":"   98","line":"        }","class":"linePartCov","hits":"1","order":"4824","possible_hits":"2",},
{"lineNum":"   99","line":"    }"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    impl Secp256k1<All> {"},
{"lineNum":"  102","line":"        /// Creates a new Secp256k1 context with all capabilities"},
{"lineNum":"  103","line":"        pub fn new() -> Secp256k1<All> {","class":"lineCov","hits":"1","order":"3802","possible_hits":"1",},
{"lineNum":"  104","line":"            Secp256k1::gen_new()","class":"lineCov","hits":"1","order":"3803","possible_hits":"1",},
{"lineNum":"  105","line":"        }","class":"linePartCov","hits":"1","order":"4825","possible_hits":"2",},
{"lineNum":"  106","line":"    }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    impl Secp256k1<SignOnly> {"},
{"lineNum":"  109","line":"        /// Creates a new Secp256k1 context that can only be used for signing"},
{"lineNum":"  110","line":"        pub fn signing_only() -> Secp256k1<SignOnly> {"},
{"lineNum":"  111","line":"            Secp256k1::gen_new()"},
{"lineNum":"  112","line":"        }"},
{"lineNum":"  113","line":"    }"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    impl Secp256k1<VerifyOnly> {"},
{"lineNum":"  116","line":"        /// Creates a new Secp256k1 context that can only be used for verification"},
{"lineNum":"  117","line":"        pub fn verification_only() -> Secp256k1<VerifyOnly> {"},
{"lineNum":"  118","line":"            Secp256k1::gen_new()"},
{"lineNum":"  119","line":"        }"},
{"lineNum":"  120","line":"    }"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"    impl Default for Secp256k1<All> {"},
{"lineNum":"  123","line":"        fn default() -> Self {"},
{"lineNum":"  124","line":"            Self::new()"},
{"lineNum":"  125","line":"        }"},
{"lineNum":"  126","line":"    }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"    impl<C: Context> Clone for Secp256k1<C> {"},
{"lineNum":"  129","line":"        fn clone(&self) -> Secp256k1<C> {"},
{"lineNum":"  130","line":"            let clone_size = unsafe {ffi::secp256k1_context_preallocated_clone_size(self.ctx)};"},
{"lineNum":"  131","line":"            let ptr_buf = Box::into_raw(vec![0u8; clone_size].into_boxed_slice());"},
{"lineNum":"  132","line":"            Secp256k1 {"},
{"lineNum":"  133","line":"                ctx: unsafe { ffi::secp256k1_context_preallocated_clone(self.ctx, ptr_buf as *mut c_void) },"},
{"lineNum":"  134","line":"                phantom: PhantomData,"},
{"lineNum":"  135","line":"                buf: ptr_buf,"},
{"lineNum":"  136","line":"            }"},
{"lineNum":"  137","line":"        }"},
{"lineNum":"  138","line":"    }"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"}"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"impl<\'buf> Signing for SignOnlyPreallocated<\'buf> {}"},
{"lineNum":"  143","line":"impl<\'buf> Signing for AllPreallocated<\'buf> {}"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"impl<\'buf> Verification for VerifyOnlyPreallocated<\'buf> {}"},
{"lineNum":"  146","line":"impl<\'buf> Verification for AllPreallocated<\'buf> {}"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"unsafe impl<\'buf> Context for SignOnlyPreallocated<\'buf> {"},
{"lineNum":"  149","line":"    const FLAGS: c_uint = ffi::SECP256K1_START_SIGN;"},
{"lineNum":"  150","line":"    const DESCRIPTION: &\'static str = \"signing only\";"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    fn deallocate(_ptr: *mut [u8]) {"},
{"lineNum":"  153","line":"        // Allocated by the user"},
{"lineNum":"  154","line":"    }"},
{"lineNum":"  155","line":"}"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"unsafe impl<\'buf> Context for VerifyOnlyPreallocated<\'buf> {"},
{"lineNum":"  158","line":"    const FLAGS: c_uint = ffi::SECP256K1_START_VERIFY;"},
{"lineNum":"  159","line":"    const DESCRIPTION: &\'static str = \"verification only\";"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"    fn deallocate(_ptr: *mut [u8]) {"},
{"lineNum":"  162","line":"        // Allocated by the user"},
{"lineNum":"  163","line":"    }"},
{"lineNum":"  164","line":"}"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"unsafe impl<\'buf> Context for AllPreallocated<\'buf> {"},
{"lineNum":"  167","line":"    const FLAGS: c_uint = SignOnlyPreallocated::FLAGS | VerifyOnlyPreallocated::FLAGS;"},
{"lineNum":"  168","line":"    const DESCRIPTION: &\'static str = \"all capabilities\";"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    fn deallocate(_ptr: *mut [u8]) {"},
{"lineNum":"  171","line":"        // Allocated by the user"},
{"lineNum":"  172","line":"    }"},
{"lineNum":"  173","line":"}"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"impl<\'buf, C: Context + \'buf> Secp256k1<C> {"},
{"lineNum":"  176","line":"    /// Lets you create a context with preallocated buffer in a generic manner(sign/verify/all)"},
{"lineNum":"  177","line":"    pub fn preallocated_gen_new(buf: &\'buf mut [u8]) -> Result<Secp256k1<C>, Error> {"},
{"lineNum":"  178","line":"        if buf.len() < Self::preallocate_size_gen() {"},
{"lineNum":"  179","line":"            return Err(Error::NotEnoughMemory);"},
{"lineNum":"  180","line":"        }"},
{"lineNum":"  181","line":"        Ok(Secp256k1 {"},
{"lineNum":"  182","line":"            ctx: unsafe {"},
{"lineNum":"  183","line":"                ffi::secp256k1_context_preallocated_create("},
{"lineNum":"  184","line":"                    buf.as_mut_ptr() as *mut c_void,"},
{"lineNum":"  185","line":"                    C::FLAGS)"},
{"lineNum":"  186","line":"            },"},
{"lineNum":"  187","line":"            phantom: PhantomData,"},
{"lineNum":"  188","line":"            buf: buf as *mut [u8],"},
{"lineNum":"  189","line":"        })"},
{"lineNum":"  190","line":"    }"},
{"lineNum":"  191","line":"}"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"impl<\'buf> Secp256k1<AllPreallocated<\'buf>> {"},
{"lineNum":"  194","line":"    /// Creates a new Secp256k1 context with all capabilities"},
{"lineNum":"  195","line":"    pub fn preallocated_new(buf: &\'buf mut [u8]) -> Result<Secp256k1<AllPreallocated<\'buf>>, Error> {"},
{"lineNum":"  196","line":"        Secp256k1::preallocated_gen_new(buf)"},
{"lineNum":"  197","line":"    }"},
{"lineNum":"  198","line":"    /// Uses the ffi `secp256k1_context_preallocated_size` to check the memory size needed for a context"},
{"lineNum":"  199","line":"    pub fn preallocate_size() -> usize {"},
{"lineNum":"  200","line":"        Self::preallocate_size_gen()"},
{"lineNum":"  201","line":"    }"},
{"lineNum":"  202","line":"}"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"impl<\'buf> Secp256k1<SignOnlyPreallocated<\'buf>> {"},
{"lineNum":"  205","line":"    /// Creates a new Secp256k1 context that can only be used for signing"},
{"lineNum":"  206","line":"    pub fn preallocated_signing_only(buf: &\'buf mut [u8]) -> Result<Secp256k1<SignOnlyPreallocated<\'buf>>, Error> {"},
{"lineNum":"  207","line":"        Secp256k1::preallocated_gen_new(buf)"},
{"lineNum":"  208","line":"    }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    /// Uses the ffi `secp256k1_context_preallocated_size` to check the memory size needed for the context"},
{"lineNum":"  211","line":"    #[inline]"},
{"lineNum":"  212","line":"    pub fn preallocate_signing_size() -> usize {"},
{"lineNum":"  213","line":"        Self::preallocate_size_gen()"},
{"lineNum":"  214","line":"    }"},
{"lineNum":"  215","line":"}"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"impl<\'buf> Secp256k1<VerifyOnlyPreallocated<\'buf>> {"},
{"lineNum":"  218","line":"    /// Creates a new Secp256k1 context that can only be used for verification"},
{"lineNum":"  219","line":"    pub fn preallocated_verification_only(buf: &\'buf mut [u8]) -> Result<Secp256k1<VerifyOnlyPreallocated<\'buf>>, Error> {"},
{"lineNum":"  220","line":"        Secp256k1::preallocated_gen_new(buf)"},
{"lineNum":"  221","line":"    }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    /// Uses the ffi `secp256k1_context_preallocated_size` to check the memory size needed for the context"},
{"lineNum":"  224","line":"    #[inline]"},
{"lineNum":"  225","line":"    pub fn preallocate_verification_size() -> usize {"},
{"lineNum":"  226","line":"        Self::preallocate_size_gen()"},
{"lineNum":"  227","line":"    }"},
{"lineNum":"  228","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "ser_de-d029ad6af9d5a7c5", "date" : "2019-08-31 07:54:50", "instrumented" : 13, "covered" : 13,};
var merged_data = [];
