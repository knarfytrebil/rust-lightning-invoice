var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin Hashes Library","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"    2","line":"// Written in 2018 by"},
{"lineNum":"    3","line":"//   Andrew Poelstra <apoelstra@wpsoftware.net>"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    6","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    7","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    8","line":"// any warranty."},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   11","line":"// along with this software."},
{"lineNum":"   12","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   13","line":"//"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"//! # Rust Hashes Library"},
{"lineNum":"   16","line":"//!"},
{"lineNum":"   17","line":"//! This is a simple, no-dependency library which implements the hash functions"},
{"lineNum":"   18","line":"//! needed by Bitcoin. These are SHA256, SHA256d, and RIPEMD160. As an ancillary"},
{"lineNum":"   19","line":"//! thing, it exposes hexadecimal serialization and deserialization, since these"},
{"lineNum":"   20","line":"//! are needed to display hashes anway."},
{"lineNum":"   21","line":"//!"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"// Coding conventions"},
{"lineNum":"   24","line":"#![deny(non_upper_case_globals)]"},
{"lineNum":"   25","line":"#![deny(non_camel_case_types)]"},
{"lineNum":"   26","line":"#![deny(non_snake_case)]"},
{"lineNum":"   27","line":"#![deny(unused_mut)]"},
{"lineNum":"   28","line":"#![deny(missing_docs)]"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"#![cfg_attr(all(not(test), not(feature = \"std\")), no_std)]"},
{"lineNum":"   31","line":"#![cfg_attr(all(test, feature = \"unstable\"), feature(test))]"},
{"lineNum":"   32","line":"#[cfg(all(test, feature = \"unstable\"))] extern crate test;"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"#[cfg(any(test, feature=\"std\"))] extern crate core;"},
{"lineNum":"   35","line":"#[cfg(feature=\"serde\")] extern crate serde;"},
{"lineNum":"   36","line":"#[cfg(all(test,feature=\"serde\"))] extern crate serde_test;"},
{"lineNum":"   37","line":"extern crate byteorder;"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"#[macro_use] mod util;"},
{"lineNum":"   40","line":"#[macro_use] mod serde_macros;"},
{"lineNum":"   41","line":"#[cfg(any(test, feature = \"std\"))] mod std_impls;"},
{"lineNum":"   42","line":"pub mod error;"},
{"lineNum":"   43","line":"pub mod hex;"},
{"lineNum":"   44","line":"pub mod hash160;"},
{"lineNum":"   45","line":"pub mod hmac;"},
{"lineNum":"   46","line":"pub mod ripemd160;"},
{"lineNum":"   47","line":"pub mod sha1;"},
{"lineNum":"   48","line":"pub mod sha256;"},
{"lineNum":"   49","line":"pub mod sha512;"},
{"lineNum":"   50","line":"pub mod sha256d;"},
{"lineNum":"   51","line":"pub mod siphash24;"},
{"lineNum":"   52","line":"pub mod cmp;"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"use core::{borrow, fmt, hash, ops};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"pub use hmac::{Hmac, HmacEngine};"},
{"lineNum":"   57","line":"pub use error::Error;"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"/// A hashing engine which bytes can be serialized into. It is expected"},
{"lineNum":"   60","line":"/// to implement the `io::Write` trait, but to never return errors under"},
{"lineNum":"   61","line":"/// any conditions."},
{"lineNum":"   62","line":"pub trait HashEngine: Clone {"},
{"lineNum":"   63","line":"    /// Byte array representing the internal state of the hash engine"},
{"lineNum":"   64","line":"    type MidState;"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"    /// Outputs the midstate of the hash engine. This function should not be"},
{"lineNum":"   67","line":"    /// used directly unless you really know what you\'re doing."},
{"lineNum":"   68","line":"    fn midstate(&self) -> Self::MidState;"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    /// Length of the hash\'s internal block size, in bytes"},
{"lineNum":"   71","line":"    const BLOCK_SIZE: usize;"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    /// Add data to the hash engine"},
{"lineNum":"   74","line":"    fn input(&mut self, data: &[u8]);"},
{"lineNum":"   75","line":"}"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"/// Trait which applies to hashes of all types"},
{"lineNum":"   78","line":"pub trait Hash: Copy + Clone + PartialEq + Eq + Default + PartialOrd + Ord +"},
{"lineNum":"   79","line":"    hash::Hash + fmt::Debug + fmt::Display + fmt::LowerHex +"},
{"lineNum":"   80","line":"    ops::Index<ops::RangeFull, Output = [u8]> +"},
{"lineNum":"   81","line":"    ops::Index<ops::RangeFrom<usize>, Output = [u8]> +"},
{"lineNum":"   82","line":"    ops::Index<ops::RangeTo<usize>, Output = [u8]> +"},
{"lineNum":"   83","line":"    ops::Index<ops::Range<usize>, Output = [u8]> +"},
{"lineNum":"   84","line":"    ops::Index<usize, Output = u8> +"},
{"lineNum":"   85","line":"    borrow::Borrow<[u8]>"},
{"lineNum":"   86","line":"{"},
{"lineNum":"   87","line":"    /// A hashing engine which bytes can be serialized into. It is expected"},
{"lineNum":"   88","line":"    /// to implement the `io::Write` trait, and to never return errors under"},
{"lineNum":"   89","line":"    /// any conditions."},
{"lineNum":"   90","line":"    type Engine: HashEngine;"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"    /// The byte array that represents the hash internally"},
{"lineNum":"   93","line":"    type Inner: hex::FromHex;"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    /// Construct a new engine"},
{"lineNum":"   96","line":"    fn engine() -> Self::Engine;"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"    /// Produce a hash from the current state of a given engine"},
{"lineNum":"   99","line":"    fn from_engine(e: Self::Engine) -> Self;"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    /// Length of the hash, in bytes"},
{"lineNum":"  102","line":"    const LEN: usize;"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"    /// Copies a byte slice into a hash object"},
{"lineNum":"  105","line":"    fn from_slice(sl: &[u8]) -> Result<Self, Error>;"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    /// Hashes some bytes"},
{"lineNum":"  108","line":"    fn hash(data: &[u8]) -> Self {","class":"linePartCov","hits":"1","order":"3456","possible_hits":"2",},
{"lineNum":"  109","line":"        let mut engine = Self::engine();","class":"lineCov","hits":"1","order":"3458","possible_hits":"1",},
{"lineNum":"  110","line":"        engine.input(data);","class":"lineCov","hits":"1","order":"3468","possible_hits":"1",},
{"lineNum":"  111","line":"        Self::from_engine(engine)","class":"lineCov","hits":"1","order":"3627","possible_hits":"1",},
{"lineNum":"  112","line":"    }","class":"lineCov","hits":"1","order":"3711","possible_hits":"1",},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    /// Flag indicating whether user-visible serializations of this hash"},
{"lineNum":"  115","line":"    /// should be backward. For some reason Satoshi decided this should be"},
{"lineNum":"  116","line":"    /// true for `Sha256dHash`, so here we are."},
{"lineNum":"  117","line":"    const DISPLAY_BACKWARD: bool = false;"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    /// Unwraps the hash and returns the underlying byte array"},
{"lineNum":"  120","line":"    fn into_inner(self) -> Self::Inner;"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"    /// Constructs a hash from the underlying byte array"},
{"lineNum":"  123","line":"    fn from_inner(inner: Self::Inner) -> Self;"},
{"lineNum":"  124","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "lightning_invoice-99c93907235ac8b4", "date" : "2019-08-31 07:54:49", "instrumented" : 6, "covered" : 5,};
var merged_data = [];
