var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin Hashes Library"},
{"lineNum":"    2","line":"// Written in 2018 by"},
{"lineNum":"    3","line":"//   Andrew Poelstra <apoelstra@wpsoftware.net>"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    6","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    7","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    8","line":"// any warranty."},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   11","line":"// along with this software."},
{"lineNum":"   12","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   13","line":"//"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"//! # Hex encoding and decoding"},
{"lineNum":"   16","line":"//!"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"use core::{fmt, str};"},
{"lineNum":"   19","line":"use {Error, Hash};"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/// Trait for objects that can be serialized as hex strings"},
{"lineNum":"   22","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"   23","line":"pub trait ToHex {"},
{"lineNum":"   24","line":"    /// Hex representation of the object"},
{"lineNum":"   25","line":"    fn to_hex(&self) -> String;"},
{"lineNum":"   26","line":"}"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"/// Trait for objects that can be deserialized from hex strings"},
{"lineNum":"   29","line":"pub trait FromHex: Sized {"},
{"lineNum":"   30","line":"    /// Produce an object from a byte iterator"},
{"lineNum":"   31","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>"},
{"lineNum":"   32","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"   33","line":"            ExactSizeIterator +"},
{"lineNum":"   34","line":"            DoubleEndedIterator;"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"    /// Produce an object from a hex string"},
{"lineNum":"   37","line":"    fn from_hex(s: &str) -> Result<Self, Error> {","class":"lineCov","hits":"1","order":"2732","possible_hits":"1",},
{"lineNum":"   38","line":"        Self::from_byte_iter(HexIterator::new(s)?)","class":"linePartCov","hits":"2","order":"2733","possible_hits":"3",},
{"lineNum":"   39","line":"    }","class":"linePartCov","hits":"2","order":"2855","possible_hits":"4",},
{"lineNum":"   40","line":"}"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"   43","line":"impl<T: fmt::LowerHex> ToHex for T {"},
{"lineNum":"   44","line":"    /// Outputs the hash in hexadecimal form"},
{"lineNum":"   45","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"   46","line":"        format!(\"{:x}\", self)"},
{"lineNum":"   47","line":"    }"},
{"lineNum":"   48","line":"}"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"impl<T: Hash> FromHex for T {"},
{"lineNum":"   51","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>","class":"linePartCov","hits":"1","order":"2760","possible_hits":"2",},
{"lineNum":"   52","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"   53","line":"            ExactSizeIterator +"},
{"lineNum":"   54","line":"            DoubleEndedIterator,"},
{"lineNum":"   55","line":"    {"},
{"lineNum":"   56","line":"        let inner;","class":"lineCov","hits":"1","order":"2761","possible_hits":"1",},
{"lineNum":"   57","line":"        if Self::DISPLAY_BACKWARD {","class":"linePartCov","hits":"2","order":"2762","possible_hits":"3",},
{"lineNum":"   58","line":"            inner = T::Inner::from_byte_iter(iter.rev())?;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   59","line":"        } else {"},
{"lineNum":"   60","line":"            inner = T::Inner::from_byte_iter(iter)?;","class":"linePartCov","hits":"1","order":"2763","possible_hits":"2",},
{"lineNum":"   61","line":"        }"},
{"lineNum":"   62","line":"        Ok(Hash::from_inner(inner))","class":"lineCov","hits":"1","order":"2850","possible_hits":"1",},
{"lineNum":"   63","line":"    }","class":"linePartCov","hits":"2","order":"2854","possible_hits":"4",},
{"lineNum":"   64","line":"}"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"/// Iterator over a hex-encoded string slice which decodes hex and yields bytes."},
{"lineNum":"   67","line":"pub struct HexIterator<\'a> {"},
{"lineNum":"   68","line":"    /// The `Bytes` iterator whose next two bytes will be decoded to yield"},
{"lineNum":"   69","line":"    /// the next byte."},
{"lineNum":"   70","line":"    iter: str::Bytes<\'a>,"},
{"lineNum":"   71","line":"}"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"impl<\'a> HexIterator<\'a> {"},
{"lineNum":"   74","line":"    /// Constructs a new `HexIterator` from a string slice. If the string is of"},
{"lineNum":"   75","line":"    /// odd length it returns an error."},
{"lineNum":"   76","line":"    pub fn new(s: &\'a str) -> Result<HexIterator<\'a>, Error> {","class":"lineCov","hits":"1","order":"2734","possible_hits":"1",},
{"lineNum":"   77","line":"        if s.len() % 2 != 0 {","class":"linePartCov","hits":"1","order":"2735","possible_hits":"2",},
{"lineNum":"   78","line":"            Err(Error::OddLengthString(s.len()))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   79","line":"        } else {"},
{"lineNum":"   80","line":"            Ok(HexIterator { iter: s.bytes() })","class":"lineCov","hits":"1","order":"2742","possible_hits":"1",},
{"lineNum":"   81","line":"        }"},
{"lineNum":"   82","line":"    }","class":"linePartCov","hits":"1","order":"2759","possible_hits":"2",},
{"lineNum":"   83","line":"}"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"fn chars_to_hex(hi: u8, lo: u8) -> Result<u8, Error> {","class":"lineCov","hits":"1","order":"2822","possible_hits":"1",},
{"lineNum":"   86","line":"    let hih = (hi as char)","class":"lineCov","hits":"3","order":"2823","possible_hits":"3",},
{"lineNum":"   87","line":"        .to_digit(16)"},
{"lineNum":"   88","line":"        .ok_or(Error::InvalidChar(hi))?;","class":"linePartCov","hits":"2","order":"2831","possible_hits":"4",},
{"lineNum":"   89","line":"    let loh = (lo as char)","class":"lineCov","hits":"3","order":"2832","possible_hits":"3",},
{"lineNum":"   90","line":"        .to_digit(16)"},
{"lineNum":"   91","line":"        .ok_or(Error::InvalidChar(lo))?;","class":"lineCov","hits":"2","order":"2833","possible_hits":"2",},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    let ret = (hih << 4) + loh;","class":"linePartCov","hits":"1","order":"2834","possible_hits":"3",},
{"lineNum":"   94","line":"    Ok(ret as u8)","class":"lineCov","hits":"1","order":"2835","possible_hits":"1",},
{"lineNum":"   95","line":"}","class":"linePartCov","hits":"2","order":"2836","possible_hits":"3",},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"impl<\'a> Iterator for HexIterator<\'a> {"},
{"lineNum":"   98","line":"    type Item = Result<u8, Error>;"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    fn next(&mut self) -> Option<Result<u8, Error>> {","class":"lineCov","hits":"1","order":"2799","possible_hits":"1",},
{"lineNum":"  101","line":"        let hi = self.iter.next()?;","class":"lineCov","hits":"3","order":"2801","possible_hits":"3",},
{"lineNum":"  102","line":"        let lo = self.iter.next().unwrap();","class":"lineCov","hits":"1","order":"2818","possible_hits":"1",},
{"lineNum":"  103","line":"        Some(chars_to_hex(hi, lo))","class":"lineCov","hits":"1","order":"2821","possible_hits":"1",},
{"lineNum":"  104","line":"    }","class":"linePartCov","hits":"2","order":"2837","possible_hits":"4",},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    fn size_hint(&self) -> (usize, Option<usize>) {","class":"lineCov","hits":"1","order":"2770","possible_hits":"1",},
{"lineNum":"  107","line":"        let (min, max) = self.iter.size_hint();","class":"lineCov","hits":"1","order":"2771","possible_hits":"1",},
{"lineNum":"  108","line":"        (min / 2, max.map(|x| x /2))","class":"lineCov","hits":"3","order":"2778","possible_hits":"3",},
{"lineNum":"  109","line":"    }","class":"linePartCov","hits":"1","order":"2781","possible_hits":"2",},
{"lineNum":"  110","line":"}"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"impl<\'a> DoubleEndedIterator for HexIterator<\'a> {"},
{"lineNum":"  113","line":"    fn next_back(&mut self) -> Option<Result<u8, Error>> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  114","line":"        let lo = self.iter.next_back()?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  115","line":"        let hi = self.iter.next_back().unwrap();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  116","line":"        Some(chars_to_hex(hi, lo))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  117","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  118","line":"}"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"impl<\'a> ExactSizeIterator for HexIterator<\'a> {}"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"/// Output hex into an object implementing `fmt::Write`, which is usually more"},
{"lineNum":"  123","line":"/// efficient than going through a `String` using `ToHex`."},
{"lineNum":"  124","line":"pub fn format_hex(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  125","line":"    let prec = f.precision().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  126","line":"    let width = f.width().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  127","line":"    for _ in (2 * data.len())..width {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  128","line":"        f.write_str(\"0\")?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  129","line":"    }"},
{"lineNum":"  130","line":"    for ch in data.into_iter().take(prec / 2) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  131","line":"        write!(f, \"{:02x}\", *ch)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  132","line":"    }"},
{"lineNum":"  133","line":"    if prec < 2 * data.len() && prec % 2 == 1 {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  134","line":"        write!(f, \"{:x}\", data[prec / 2] / 16)?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  135","line":"    }"},
{"lineNum":"  136","line":"    Ok(())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  137","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"/// Output hex in reverse order; used for Sha256dHash whose standard hex encoding"},
{"lineNum":"  140","line":"/// has the bytes reversed."},
{"lineNum":"  141","line":"pub fn format_hex_reverse(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  142","line":"    let prec = f.precision().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  143","line":"    let width = f.width().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  144","line":"    for _ in (2 * data.len())..width {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  145","line":"        f.write_str(\"0\")?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  146","line":"    }"},
{"lineNum":"  147","line":"    for ch in data.iter().rev().take(prec / 2) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  148","line":"        write!(f, \"{:02x}\", *ch)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  149","line":"    }"},
{"lineNum":"  150","line":"    if prec < 2 * data.len() && prec % 2 == 1 {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  151","line":"        write!(f, \"{:x}\", data[data.len() - 1 - prec / 2] / 16)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  152","line":"    }"},
{"lineNum":"  153","line":"    Ok(())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  154","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"  157","line":"impl ToHex for [u8] {"},
{"lineNum":"  158","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"  159","line":"        use core::fmt::Write;"},
{"lineNum":"  160","line":"        let mut ret = String::with_capacity(2 * self.len());"},
{"lineNum":"  161","line":"        for ch in self {"},
{"lineNum":"  162","line":"            write!(ret, \"{:02x}\", ch).expect(\"writing to string\");"},
{"lineNum":"  163","line":"        }"},
{"lineNum":"  164","line":"        ret"},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":"}"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"  169","line":"impl FromHex for Vec<u8> {"},
{"lineNum":"  170","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>"},
{"lineNum":"  171","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"  172","line":"            ExactSizeIterator +"},
{"lineNum":"  173","line":"            DoubleEndedIterator,"},
{"lineNum":"  174","line":"    {"},
{"lineNum":"  175","line":"        iter.collect()"},
{"lineNum":"  176","line":"    }"},
{"lineNum":"  177","line":"}"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"macro_rules! impl_fromhex_array {"},
{"lineNum":"  180","line":"    ($len:expr) => {"},
{"lineNum":"  181","line":"        impl FromHex for [u8; $len] {"},
{"lineNum":"  182","line":"            fn from_byte_iter<I>(iter: I) -> Result<Self, Error>","class":"linePartCov","hits":"1","order":"2764","possible_hits":"4",},
{"lineNum":"  183","line":"                where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"  184","line":"                    ExactSizeIterator +"},
{"lineNum":"  185","line":"                    DoubleEndedIterator,"},
{"lineNum":"  186","line":"            {"},
{"lineNum":"  187","line":"                if iter.len() == $len {","class":"linePartCov","hits":"3","order":"2765","possible_hits":"6",},
{"lineNum":"  188","line":"                    let mut ret = [0; $len];","class":"linePartCov","hits":"1","order":"2788","possible_hits":"2",},
{"lineNum":"  189","line":"                    for (n, byte) in iter.enumerate() {","class":"linePartCov","hits":"4","order":"2789","possible_hits":"10",},
{"lineNum":"  190","line":"                        ret[n] = byte?;","class":"linePartCov","hits":"3","order":"2843","possible_hits":"8",},
{"lineNum":"  191","line":"                    }"},
{"lineNum":"  192","line":"                    Ok(ret)","class":"linePartCov","hits":"1","order":"2848","possible_hits":"2",},
{"lineNum":"  193","line":"                } else {"},
{"lineNum":"  194","line":"                    Err(Error::InvalidLength(2 * $len, 2 * iter.len()))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  195","line":"                }"},
{"lineNum":"  196","line":"            }","class":"linePartCov","hits":"2","order":"2849","possible_hits":"6",},
{"lineNum":"  197","line":"        }"},
{"lineNum":"  198","line":"    }"},
{"lineNum":"  199","line":"}"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"impl_fromhex_array!(2);"},
{"lineNum":"  202","line":"impl_fromhex_array!(4);"},
{"lineNum":"  203","line":"impl_fromhex_array!(6);"},
{"lineNum":"  204","line":"impl_fromhex_array!(8);"},
{"lineNum":"  205","line":"impl_fromhex_array!(10);"},
{"lineNum":"  206","line":"impl_fromhex_array!(12);"},
{"lineNum":"  207","line":"impl_fromhex_array!(14);"},
{"lineNum":"  208","line":"impl_fromhex_array!(16);"},
{"lineNum":"  209","line":"impl_fromhex_array!(20);"},
{"lineNum":"  210","line":"impl_fromhex_array!(24);"},
{"lineNum":"  211","line":"impl_fromhex_array!(28);"},
{"lineNum":"  212","line":"impl_fromhex_array!(32);"},
{"lineNum":"  213","line":"impl_fromhex_array!(33);"},
{"lineNum":"  214","line":"impl_fromhex_array!(64);"},
{"lineNum":"  215","line":"impl_fromhex_array!(65);"},
{"lineNum":"  216","line":"impl_fromhex_array!(128);"},
{"lineNum":"  217","line":"impl_fromhex_array!(256);"},
{"lineNum":"  218","line":"impl_fromhex_array!(384);"},
{"lineNum":"  219","line":"impl_fromhex_array!(512);"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"#[cfg(test)]"},
{"lineNum":"  222","line":"mod tests {"},
{"lineNum":"  223","line":"    use core::fmt;"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"    use super::{format_hex, format_hex_reverse, FromHex, ToHex};"},
{"lineNum":"  226","line":"    use Error;"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"    #[test]"},
{"lineNum":"  229","line":"    fn hex_roundtrip() {"},
{"lineNum":"  230","line":"        let expected = \"0123456789abcdef\";"},
{"lineNum":"  231","line":"        let expected_up = \"0123456789ABCDEF\";"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"        let parse: Vec<u8> = FromHex::from_hex(expected).expect(\"parse lowercase string\");"},
{"lineNum":"  234","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  235","line":"        let ser = parse.to_hex();"},
{"lineNum":"  236","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"        let parse: Vec<u8> = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  239","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  240","line":"        let ser = parse.to_hex();"},
{"lineNum":"  241","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"        let parse: [u8; 8] = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  244","line":"        assert_eq!(parse, [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  245","line":"        let ser = parse.to_hex();"},
{"lineNum":"  246","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  247","line":"    }"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    #[test]"},
{"lineNum":"  250","line":"    fn hex_truncate() {"},
{"lineNum":"  251","line":"        struct HexBytes(Vec<u8>);"},
{"lineNum":"  252","line":"        impl fmt::LowerHex for HexBytes {"},
{"lineNum":"  253","line":"            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  254","line":"                format_hex(&self.0, f)"},
{"lineNum":"  255","line":"            }"},
{"lineNum":"  256","line":"        }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        assert_eq!("},
{"lineNum":"  261","line":"            format!(\"{:x}\", bytes),"},
{"lineNum":"  262","line":"            \"0102030405060708090a\""},
{"lineNum":"  263","line":"        );"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"        for i in 0..20 {"},
{"lineNum":"  266","line":"            assert_eq!("},
{"lineNum":"  267","line":"                format!(\"{:.prec$x}\", bytes, prec = i),"},
{"lineNum":"  268","line":"                &\"0102030405060708090a\"[0..i]"},
{"lineNum":"  269","line":"            );"},
{"lineNum":"  270","line":"        }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        assert_eq!("},
{"lineNum":"  273","line":"            format!(\"{:25x}\", bytes),"},
{"lineNum":"  274","line":"            \"000000102030405060708090a\""},
{"lineNum":"  275","line":"        );"},
{"lineNum":"  276","line":"        assert_eq!("},
{"lineNum":"  277","line":"            format!(\"{:26x}\", bytes),"},
{"lineNum":"  278","line":"            \"0000000102030405060708090a\""},
{"lineNum":"  279","line":"        );"},
{"lineNum":"  280","line":"    }"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"    #[test]"},
{"lineNum":"  283","line":"    fn hex_truncate_rev() {"},
{"lineNum":"  284","line":"        struct HexBytes(Vec<u8>);"},
{"lineNum":"  285","line":"        impl fmt::LowerHex for HexBytes {"},
{"lineNum":"  286","line":"            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  287","line":"                format_hex_reverse(&self.0, f)"},
{"lineNum":"  288","line":"            }"},
{"lineNum":"  289","line":"        }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"        assert_eq!("},
{"lineNum":"  294","line":"            format!(\"{:x}\", bytes),"},
{"lineNum":"  295","line":"            \"0a090807060504030201\""},
{"lineNum":"  296","line":"        );"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"        for i in 0..20 {"},
{"lineNum":"  299","line":"            assert_eq!("},
{"lineNum":"  300","line":"                format!(\"{:.prec$x}\", bytes, prec = i),"},
{"lineNum":"  301","line":"                &\"0a090807060504030201\"[0..i]"},
{"lineNum":"  302","line":"            );"},
{"lineNum":"  303","line":"        }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"        assert_eq!("},
{"lineNum":"  306","line":"            format!(\"{:25x}\", bytes),"},
{"lineNum":"  307","line":"            \"000000a090807060504030201\""},
{"lineNum":"  308","line":"        );"},
{"lineNum":"  309","line":"        assert_eq!("},
{"lineNum":"  310","line":"            format!(\"{:26x}\", bytes),"},
{"lineNum":"  311","line":"            \"0000000a090807060504030201\""},
{"lineNum":"  312","line":"        );"},
{"lineNum":"  313","line":"    }"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"    #[test]"},
{"lineNum":"  316","line":"    fn hex_error() {"},
{"lineNum":"  317","line":"        let oddlen = \"0123456789abcdef0\";"},
{"lineNum":"  318","line":"        let badchar1 = \"Z123456789abcdef\";"},
{"lineNum":"  319","line":"        let badchar2 = \"012Y456789abcdeb\";"},
{"lineNum":"  320","line":"        let badchar3 = \"«23456789abcdef\";"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"        assert_eq!("},
{"lineNum":"  323","line":"            Vec::<u8>::from_hex(oddlen),"},
{"lineNum":"  324","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  325","line":"        );"},
{"lineNum":"  326","line":"        assert_eq!("},
{"lineNum":"  327","line":"            <[u8; 4]>::from_hex(oddlen),"},
{"lineNum":"  328","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  329","line":"        );"},
{"lineNum":"  330","line":"        assert_eq!("},
{"lineNum":"  331","line":"            <[u8; 8]>::from_hex(oddlen),"},
{"lineNum":"  332","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  333","line":"        );"},
{"lineNum":"  334","line":"        assert_eq!("},
{"lineNum":"  335","line":"            Vec::<u8>::from_hex(badchar1),"},
{"lineNum":"  336","line":"            Err(Error::InvalidChar(b\'Z\'))"},
{"lineNum":"  337","line":"        );"},
{"lineNum":"  338","line":"        assert_eq!("},
{"lineNum":"  339","line":"            Vec::<u8>::from_hex(badchar2),"},
{"lineNum":"  340","line":"            Err(Error::InvalidChar(b\'Y\'))"},
{"lineNum":"  341","line":"        );"},
{"lineNum":"  342","line":"        assert_eq!("},
{"lineNum":"  343","line":"            Vec::<u8>::from_hex(badchar3),"},
{"lineNum":"  344","line":"            Err(Error::InvalidChar(194))"},
{"lineNum":"  345","line":"        );"},
{"lineNum":"  346","line":"    }"},
{"lineNum":"  347","line":"}"},
{"lineNum":"  348","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "lightning_invoice-99c93907235ac8b4", "date" : "2019-08-31 07:54:49", "instrumented" : 67, "covered" : 37,};
var merged_data = [];
